#+TITLE: Gentle intro 2 CLIPS

Recall that an expert system contains a database which in turn contains a series of facts and rules (productions). Facts come in two varieties: structured facts (templates) and ad-hoc facts.

* Templates

The templates for structured tasks are specified by the ~deftemplate~ command

#+BEGIN_EXAMPLE
(deftemplate aTemplate "some documentation"
        (slot slot1)
        (slot slot2)
        (etc.)
)
#+END_EXAMPLE

For example, a student templaet may be structured as follows

#+BEGIN_EXAMPLE
(deftemplate student "A student template"
    (slot sno)
    (slot sname)
    (slot major)
    (slot advisor)
)
#+END_EXAMPLE

* Asserting facts

There are two ways of introducing facts into the CLIPS database. One way is to include them in a set of initial facts

#+BEGIN_EXAMPLE
(deffacts initial-facts
        (student (sno 123) (sname maigret) (major pre-med)
            (advisor simenon)) ... )
#+END_EXAMPLE

~deffacts~ are asserted after the CLIPS file containing them has been loaded into CLIPS (see below) and then after the (reset) command.

Another way to assert a fact is to assert it "on the fly", generally as an action in a rule

#+BEGIN_EXAMPLE
(assert (student (sno 123) (sname maigret)
    (major pre-med) (advisor simenon)))
#+END_EXAMPLE

* Non-structured facts

It is sometimes convenient to have a series of ad-hoc facts in the database, as well as the structured ones.  These are simply lists of words between parenthesis, such as

#+BEGIN_EXAMPLE
(alarm on)
(alarm off)
(temperature high)
(valve a3572 open)
#+END_EXAMPLE

* Rules

The basis for a production system, of course, is the collection of condition-action rules.  The syntax for defining a rule is

#+BEGIN_EXAMPLE
(defrule rule-name "some documentation"
    (if-condition)
    (if-condition)
    (etc.)
=>
    (action 1)
    (action 2)
    (etc.)
)
#+END_EXAMPLE

In the example below, we have that if the unstructured facts ~(animal fierce)(animal big)(animal hungry)~ are in our KB, then all the conditions of the rule are met and ~useful-rule~ is fired, resulting in the insertion of a new assertion ~(run away)~.

#+BEGIN_EXAMPLE
(defrule useful-rule "a useful rule"
    (animal fierce)
    (animal big)
    (animal hungry)
=>
    (assert (run away))
)
#+END_EXAMPLE

* Pattern matching

Suppose that we have a fact such as

#+BEGIN_EXAMPLE
(deftemplate student "a student template"
    (slot sname)
    (slot major)
    (slot interest))

(deffacts inital-facts "some initial facts"
    (student (sname dee) (major law))
)
#+END_EXAMPLE

The following rule collects all the students majoring in law and adds to our KB the fact that they are interested in law: if there is anything in our database asserting that a student with some name is majoring in law (major law), then we want to add to our database the fact that this student is interested in law.
The use of ~?name~ is important: putting a question mark before a ~name~ says that if we find in our database a student with a name and with a law major, we put the name of that student into ?name and then use the same name in further pattern matching in the if-part and then-part of the rule. If we use the same variable in different parts of the if-part, the same values must be used.

#+BEGIN_EXAMPLE
(defrule rule-1 "a first rule"
    (student (sname ?name)(major law))
=>
    (assert (law-interest ?name))
)
#+END_EXAMPLE

With the following rule, the ~?sno~ matched in the first rule must be the same in the rest of the rule. Note the printout statement.

#+BEGIN_EXAMPLE
(defrule suggest-math-rule
    (interest ?sno math)
    (ability ?sno math)
    (student (sno ?sno) (sname ?sname))
=>
    (assert (suggest ?sno take-math))
    (printout t "We suggest that " ?sname "take some more math")
)
#+END_EXAMPLE
* Editing facts

The ~(interest nil)~ says that this rule should fire only if we don't have a value for interest yet. The ~?f1~ does two things
- In the first occurrence of ~?f1~, ~?f1 <- (student (sname ?name) (major law))~, we bind the fact number of the fact into the variable ~?f1~.
- We can then use that stored value to modify the rule by changing the value of the existing (slot interest) with the value (interest law). There must be a slot with this name, otherwise nothing works.

#+BEGIN_EXAMPLE
(defrule rule-2 "a second rule"
    ?f1 <- (student (sname ?name) (major law) (interest nil))
=>
    (modify ?f1 (interest law))
)
#+END_EXAMPLE
* Examples
** Structured frame with ~deftemplate~, variables and frame editing

#+BEGIN_SRC sh :results output drawer
cat ./01.clp.txt
#+END_SRC

#+RESULTS:
:results:
;
; This example illustrates three ideas:
; 1. The use of a structured frame (deftemplate)
; 2. The use of variables (?name)
; 3. A way to modify an existing frame
;

(deftemplate student "a student template"
(slot sname)
(slot major)
(slot interest))
;
; This defines a frame with three slots (sname, major, interest)
;
(deffacts initial-facts "some initial facts"
(student (sname dee) (major law))
)
;
; Remember that initial-facts will be loaded into the
; CLIPS database when a (reset) command is issued.
;
(defrule rule-1 "a first rule"
(student (sname ?name) (major law))
=>
(assert (law-interest ?name))
)
;
; This first rule says that if we find a student frame
; in the database, we will grab the value in the 'sname' slot
; and place the value we find there into the variable ?name. All
; variables in CLIPS begin with an initial question mark.
; After doing this, we then assert into the database a fact
; (law-interest ?name)
; The ?name picked up from the student frame is inserted. Since we
; know that Dee (Judge Dee, middle Tang dynasty) is majoring in law,
; the result will be to add a fact that (law-interest dee)
;
(defrule rule-2 "a second rule"
?f1 <- (student (sname ?name) (major law) (interest nil))
=>
(modify ?f1 (interest law))
)
;
; In this rule we modify the student frame for students whose major
; is law. (major law) in a student frame indicates that the student's
; major is law. (interest nil) means that we do not yet have any
; interest value for this student. The use of ?f1 says that if we find
; such a record (Dee again, in this case) we store an identifier to that
; frame in the variable ?f1. In the "then-part" of the rule, we modify
; that rule to add that the student (Dee again) is interested in law.
; This is actually a deletion of the first frame and an insertion of the
; modified frame)
:end:

** ~printout~ command

#+BEGIN_SRC sh :results output drawer
tail -n 12 ./02.clp.txt
#+END_SRC

#+RESULTS:
:results:
(defrule rule-1 "a first rule"
(student (sname ?name) (major law))
=>
(assert (law-interest ?name))
(printout t ?name " would be interested in Law" crlf)
)
;
; Notice the format of the printout command. The 't' is
; there to say that the output should go to the terminal
; (stdout). Variables can be mixed with text (in double-
; quotes). crlf means produce a carriage return at the
; end of the text.
:end:

** ~read~ and ~test~ commands

#+BEGIN_SRC sh :results output drawer
tail -n 30 ./03.clp.txt
#+END_SRC

#+RESULTS:
:results:
(deftemplate enroll "enrollment records"
(slot sname)
(slot cname)
(slot grade))
(deffacts initial-facts "some initial facts"
(student (sname dee) (major law))
(enroll (sname dee) (cname STS350) (grade nil))
)
;
; Remember that initial-facts will be loaded into the
; CLIPS database when a (reset) command is issued.
;

(defrule ask-grade-rule
(student (sname ?name))
?f1 <- (enroll (sname ?name) (cname ?cnme) (grade nil))
=>
(printout t "Please enter the grade in " ?cnme " for " ?name "-->")
(bind ?score (read))
(modify ?f1 (grade ?score))
)
;
(defrule check-grade-rule
(student (sname ?name))
(enroll (sname ?name) (cname ?cnme) (grade ?sgrade))
(test (numberp ?sgrade))
(test (>= ?sgrade 3.0))
=>
(printout t "Student " ?name " did well in " ?cnme crlf)
)
:end:

** Template with ~multislot~ and slot with ~type~

Multislot values have to be captured by multi-field variables ~$?<name>~ in rule premises

#+BEGIN_SRC sh :results output drawer
cat ./04.clp.txt
#+END_SRC

#+RESULTS:
:results:
(deftemplate student "A student frame"
(slot sno)
(slot sname)
(slot major)
(multislot interests))
(deftemplate enroll "students enrolled in classes"
(slot sno)
(slot cno)
(slot grade (type NUMBER)))
(deftemplate class "classes students take"
(slot cno)
(slot cname)
(slot dept))
(defrule cogsci-rule-1
(student (sno ?sno) (sname ?sname) (major ?major)
(interests $? psych $?))
=>
(printout t ?sname "would be interested in SCXT 350" crlf)
)
;
(deffacts Initial-facts
(student (sno s01) (sname Poirot) (major csci)
(interests music go psych ceramics))
)
:end:

** Slightly more complex student example

#+BEGIN_SRC sh :results output drawer
cat ./05.clp.txt
#+END_SRC

#+RESULTS:
:results:
(deftemplate student "A student record"
(slot sno)
(slot sname)
(slot major)
(slot wcomm)
(slot scxt)
(slot units) ; Number of units passed
(slot satm)
(slot satv))
;
(deftemplate enroll
(slot sno)
(slot cno))
;
(deftemplate class
(slot cno)
(slot cname)
(slot dept))
;
(defrule suggest-math-rule
(interest ?sno math)
(ability ?sno math)
=>
(assert (suggest ?sno take-math))
)
;
(defrule find-math-interest
(student (sno ?snumb))
(enroll (sno ?snumb) (cno ?cnumb))
(class (cno ?cnumb) (dept math))
=>
(assert (interest ?snumb math))
)
;
(defrule find-math-ability
(student (sno ?snumb) (satm ?score))
(test (and (numberp ?score)
(> ?score 600)))
=>
(assert (ability ?snumb math))
)
;
(deffacts initial-facts
(student (sno 123) (sname "Marple"))
(enroll (sno 123) (cno 321))
(class (cno 321) (cname "Naive Quantum Mechanics") (dept math))
)
;
(defrule ask-satm-rule
?f1 <- (student (sno ?snumb) (sname ?name) (satm nil))
=>
(printout t "Please enter the sat math score for " ?name " ")
(bind ?score (read))
(modify ?f1 (satm ?score))
)
:end:

* Resources
- [[http://math.ups.edu/~matthews/STS350_S2006/CLIPS.htm][A gentle introduction to CLIPS for CogSci Students]]
