#+TITLE: Class

* Rules

~defrule~ command examples

#+BEGIN_SRC sh :results output code
cat ./rich.clp.txt
#+END_SRC

#+RESULTS:
#+begin_src sh
(defrule R1 "rich people are happy"
  (rich ?x)
=>
  (assert (happy ?x)))

(defrule R1 "rich people are happy"
  (rich ?x)
  (healthy ?x)
=>
  (assert (happy ?x))
  (printout t "one new happy person " ?x crlf)
)

(defrule R2 "parents of happy people are happy"
  (happy ?x)
  (parent ?y ?x)
=>
  (happy ?y))
  (defrule R3 "define rich people" (earns-money ?x) => (assert (rich ?x))
)
#+end_src
* Templates
** World of blocks

- ~allow-symbols~ to set slot domain
- Predicate constraints with ~(slot ?s&:(condition))~

#+BEGIN_SRC sh :results output code
cat ./wob.clp.txt
#+END_SRC

#+RESULTS:
#+begin_src sh
; World of blocks with templates

(deftemplate block
  (slot name)
  (slot size)
  (slot position (allowed-symbols Table Robot Heap))
)

(deffacts F1
  (block (name B1) (size 10) (position Table))
  (block (name B2) (size 20) (position Table))
  (block (name B3) (size 30) (position Table))
)

;
; Here we have predicate constraint: a condition that must be satisfied before matching a fact
; (slot ?s&:(condition))
;
; We use it to modify the position of a block from Table to Robot if
; there is no bigger block than that one, and if there is its not in the heap
;
(defrule R1 "pick-up block"
  ?id <- (block (name ?name) (size ?size) (position Table))
	 (not (block (size ?size2&:(> ?size2 ?size)) (position ?position&:(neq ?position Heap))))
=>
  (modify ?id (position Robot))
)

;
; Note the row
; (not (block (size ?size3&:(< ?size3 ?size2)) (position Heap)))
; this constraints the block to be put on the smallest block in the heap
;

(defrule R2 "release block"
  ?id <- (block (name ?name) (size ?size) (position Robot))
         (block (name ?name2) (size ?size2) (position Heap))
	 (not (block (size ?size3&:(< ?size3 ?size2)) (position Heap)))
=>
  (modify ?id (position Heap))
  (assert (on ?name ?name2))
  (printout t "block " ?name " stacked on " ?name2 crlf)
)

(defrule R2-1 "release first block"
  ?id <- (block (name ?name) (size ?size) (position Robot))
         (not (block (position Heap)))
=>
  (modify ?id (position Heap))
  (assert (on ?name Heap))
)
#+end_src

** Railway

- ~defglobal~ for global variables
- ~salience~ to set rule priority

#+BEGIN_SRC sh :results output code
cat ./railway.clp.txt
#+END_SRC

#+RESULTS:
#+begin_src sh
; Railway problems with templates

;
; Stations are represented with numbers 1,2,3,...
;
(defglobal ?*num-stations* = 3)

(deftemplate train
  (slot capacity)
  (slot station)
  (slot state (allowed-values stopped moving))
)

(deftemplate passenger
  (slot id)
  (slot station)
  (slot destination)
  (slot state (allowed-values waiting on-train))
)

(deffacts F
  (train (capacity 2) (station 1) (state stopped))
  (passenger (id 1) (station 1) (destination 2) (state waiting))
  (passenger (id 2) (station 2) (destination 1) (state waiting))
  (passenger (id 3) (station 3) (destination 1) (state waiting))
)

(defrule get-on-train "a new person enters the train"
  ?t <- (train (capacity ?c&:(> ?c 0)) (station ?s) (state stopped))
  ?p <- (passenger (id ?id) (station ?s) (state waiting))
=>
  (modify ?t (capacity (- ?c 1)))
  (modify ?p (state on-train))
  (printout t "passenger " ?id " gets into the train" crlf)
)

;
; Note the salience 10 to set the rule priority
;
(defrule get-off-train "a person leaves the train"
  (declare (salience 10))
  ?t <- (train (capacity ?c) (station ?s) (state stopped))
  ?p <- (passenger (id ?id) (destination ?s) (state on-train))
=>
  (modify ?t (capacity (+ ?c 1))) (retract ?p)
  (printout t "passenger " ?id " arrives to destination " ?s crlf)
)

(defrule move-train "go to next station"
  ?t <- (train (station ?s) (state stopped)) (passenger)
=>
  (modify ?t (state moving)) (printout t "the train leaves station " ?s crlf)
)

(defrule train-arrival "train arrives to station"
  ?t <- (train (station ?s) (state moving))
=>
  (modify ?t (station (+ 1 (mod ?s ?*num-stations*))) (state stopped))
  (printout t "train arrives in next station " crlf)
)
#+end_src
